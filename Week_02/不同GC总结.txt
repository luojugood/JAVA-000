不同GC总结：
垃圾收集器
一、串行GC
Serial收集器：Serial是一个单线程收集器。是新生代收集器。
ParNew收集器：ParNew收集器其实就是Serial收集器的多线程版本。除了多线程进行垃圾收集之外，其他都和Serial一样。是新生代收集器。
二、并行GC
Parallel Scavenge收集器：Parallel Scavenge是新生代收集器。它也是使用复制算法的收集器，又是并行的多线程收集器。Parallel Scavenge收集器提供了参数控制最大垃圾收集停顿时间，虚拟机将尽可能保证垃圾回收的时间不超过该值。不过大家不要任
务把这个参数的值设小一点就可以使垃圾收集速度加快，GC停顿时间缩短，是以牺牲吞吐量和新生代空间来换取的，由于和吞吐量关系密切，Parallel Scavenge也被称为吞吐量优先收集器。
三、CMS GC
CMS收集器：CMS是一种以获取最短停顿时间为目标的收集器。
CMS收集器基于标记-清除算法实现的。它的运作过程分为4个步骤：初始标记、并发标记、重新标记、并发清除。
其中，初始标记、重新标记两个步骤仍然需要暂停用户线程。
1.初始标记仅仅是标记一下GC Roots能够直接关联的对象，速度很快。
2.并发标记就是进行GC Roots 向下查找过程，也就是从GC Roots开始，对堆中对象进行可达性分析。这时候用户线程还可以继续执行。
3.重新标记阶段是为了修正并发标记期间因用户线程继续运作而导致标记产生变动的那一部分对象标记记录。这个阶段的标记时间一般比初始标记稍长一点，但远比并发标记时间短。
4.并发清除是GC垃圾收集线程 和 用户线程并行的，清理被回收的对象。
由于整个过程中耗时最长的并发标记和并发清除的阶段收集器都可以和用户线程并行工作，所以总体上来说，CMS收集器的内存回收是与用户线程一起并发执行的。

优点：减少了GC停顿时间
缺点：
	1.对CPU资源敏感，在并发阶段，因为占用一部分CPU资源，因此会导致程序变慢。当CPU个数比较少的时候，对用户影响可能很大。
	2.无法处理浮动垃圾。在并发清除阶段，用户线程还在运行着，还会产生新的垃圾。这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留到下一次GC的时候再清理掉。这一部分垃圾就称为浮动垃圾。
	3.CMS是一块基于标记-清除实现的垃圾收集器，那么在收集结束时会有大量内存碎片产生。当内存碎片过多的时候，如果要对大对象进行内存分配，但是无法找到足够大的连续内存空间进行分配，就会触发一次Full GC。
四、G1 GC
G1收集器：G1收集器是一款面向服务端应用的垃圾收集器。G1将堆分成许多大小相同的区域单元，每个单元称为Region，Region是一块地址连续的内存空间。
G1收集器具备如下特点：
1.并发与并行：G1能充分利用CPU、多核环境的硬件优势。使用多个CPU缩短Stop the world，也就是工作线程的暂停时间。在执行GC动作的同时，G1收集器仍然能够通过并发的方式让Java程序执行。
2.分代收集：与其他收集器一样，分代概念在G1收集器中仍然得以保留。虽然G1收集器不用其他收集器配合技能管理整个GC堆，但他依然能够采用不同方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象 以取得更好的收集效果。
3.空间整合：G1整体上看是基于标记-整理算法实现的收集器，从局部看（两个Region之间），是基于复制算法实现的。使用这两种算法，在G1运行期间不会产生内存碎片，垃圾收集后，能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
4.可预测的停顿：G1除了追求减低停顿以外，还建立了可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

Minor GC
Minor GC又称为新生代GC。指发生在新生代的垃圾收集动作。因为Java对象大多很快死亡，所以Minor GC非常频繁，一般回收速度也比较快。
Major GC/Full GC
又称为老年代GC。指发生在老年代的GC。出现了Major GC，经常伴随着一次Minor GC。Major GC一般速度比Minor GC慢10倍以上。